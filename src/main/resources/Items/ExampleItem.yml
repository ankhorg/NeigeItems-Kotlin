ExampleItem:
  # 物品材质
  material: LEATHER_HELMET
  # 物品CustomModelData(适用于1.14+)
  custommodeldata: 1
  # 物品损伤值
  damage: 1
  # 物品名
  name: §6一件皮革甲
  # 物品Lore
  lore:
  - 'PAPI变量测试: %player_level%'
  - '16进制颜色测试: <#ABCDEF>好耶'
  - '私有简单节点测试: <simple-1>'
  - '私有字符串节点测试: <strings-1>'
  - '私有随机数节点测试: <number-1>'
  - '私有公式节点测试: <calculation-1>'
  - '私有权重节点测试: <weight-1>'
  - '私有JavaScript节点测试: <js-1>'
  - '即时声明字符串节点测试: <strings::number-1_weight-1>'
  - '即时声明随机数节点测试: <number::0_10_0>'
  - '即时声明公式节点测试: <calculation::1+1+3+<number-1>_2>'
  - '即时声明权重节点测试: <weight::5::权重文本1_1::权重文本2>'
  - '即时声明papi节点测试: <papi::<papiString-1><papiString-2>>'
  - '即时声明JavaScript节点测试: <js::ExampleScript.js::main>'
  - '全局节点调用测试: <global-strings-1>'
  - '嵌套识别测试: <<strings-1>>'
  - '文本中小于号请添加反斜杠, 防止错误识别'
  - '形如: \<\<\<\>\>\>'
  - '请尽量避免使用即时声明节点'
  - "换行符测试\n换行符测试"
  # 物品附魔
  enchantments:
    ARROW_DAMAGE: 1
    ARROW_KNOCKBACK: 1
  # 物品隐藏标识
  hideflags:
  - HIDE_ATTRIBUTES
  - HIDE_DESTROYS
  # 物品颜色(适用于药水/皮革装备)
  color: 65535
  # 额外选项
  options:
    charge: 10
    color: GOLD
  # 物品NBT
  nbt:
    # NBT中也可以随机调用节点
    <strings::文本1_文本2_文本3_文本4>: 114514
    # 可以在NBT中编辑物品的原版属性
    AttributeModifiers:
    - Amount: 10
      AttributeName: minecraft:generic.max_health
      Operation: 0
      UUID:
      - 0
      - 31453
      - 0
      - 59664
      Name: generic.maxHealth
  # 引用的全局节点
  globalsections:
  # 这种直接填写文件名的方式可以直接调用文件内的全部全局节点
  # - ExampleSection.yml
  - global-strings-1
  - global-number-1
  # 物品私有节点
  sections:
    simple-1: <strings::text1_text2_text3>
    strings-1:
      type: strings
      values:
      - 测试文本1
      - 测试文本2
    number-1:
      type: number
      min: 1
      max: 2
      fixed: 3
    calculation-1:
      type: calculation
      formula: 1+2+3<number-1>+<number-1>
      min: 1
      max: 100
      fixed: 3
    weight-1:
      type: weight
      values:
      - 5::第一行
      - 1::第二行
    js-1:
      type: js
      path: ExampleScript.js::main
    papiString-1:
      type: strings
      values:
      - "player_"
    papiString-2:
      type: strings
      values:
      - "name"
ExampleItem2:
  material: STONE
ExampleItem3:
  material: STONE
ExampleItem4:
  material: STONE
  name: "&f%neigeitems_nbt_NeigeItems.id%"
  lore:
  - '&f物品使用次数: %neigeitems_charge%/%neigeitems_maxCharge%'
  options:
    charge: 10

# Check节点测试
CheckTest:
  material: STONE
  name: <check>
  sections:
    # 待检查的节点, 随机返回test1, test2, test3中的一个值
    test:
      type: strings
      values:
        - test1
        - test2
        - test3
    check:
      type: check
      # 待检查的值
      value: <test>
      # 执行动作
      # 条件中默认导入了value
      actions:
          # 如果value为test1
        - condition: value == "test1"
          # 通知玩家
          actions:
          - "tell: 你得到了名为 test1 的物品"
          # value不为test1
          deny:
            # value为test2
            condition: value == "test2"
            # 通知玩家
            actions:
            - "tell: 你得到了名为 test2 的物品"
            # value不为test2
            deny:
              # value为test3
              condition: value == "test3"
              # 通知玩家
              actions:
              - "tell: 你得到了名为 test3 的物品"

ComboTest:
  material: DIAMOND

# 一个测试模板
template1:
  material: IRON_SWORD
  lore:
  - "&e攻击伤害: &f<damage>"
  nbt:
    MMOITEMS_ATTACK_DAMAGE: (Double) <damage>
# 一个测试模板
template2:
  material: DIAMOND_SWORD

# 一个全局继承测试, 它继承了"template1"的所有内容
TemplateItem1:
  inherit: template1
  name: §f物品继承测试
  sections:
    damage: 100
# 一个部分继承测试, 它继承了"template1"的lore, 以及"template2"的material
TemplateItem2:
  inherit: 
    lore: template1
    material: template2
  name: §f物品继承测试
  sections:
    damage: 100
# 一个顺序继承测试, 它将按顺序进行节点继承. 先继承"template1"的所有内容，再继承"template2"的所有内容
TemplateItem3:
  inherit:
  - template1
  - template2
  name: §f物品继承测试
  sections:
    damage: 100'

# 继承节点测试
InheritSectionTest:
  material: STONE
  lore:
  - <templateTest>
  - <inheritTest>
  - <inherit::templateTest>
  sections:
    templateTest: <strings::text1_text2_text3>
    inheritTest:
      type: inherit
      template: templateTest

# 物品动作测试
ActionTest:
  material: STONE
  name: <test>
  nbt:
    test1: "666"
    test2: 
      test3: "777"
    test4:
    - "888"
    - "999"
  sections:
    test: "yeah"

# 自定义节点测试
CustomSection:
  material: STONE
  lore:
    - '自定义节点测试: <test-1>'
    - '自定义节点测试: <test::test_test_test>'
  sections:
    test-1:
      type: test
      values:
        - test
        - test
        - test
        - test

# 物品动作Eat触发器测试
EatTest1:
  material: APPLE
EatTest2:
  material: APPLE
  options:
    charge: 10

# 物品动作Drop触发器测试
DropTest1:
  material: STONE
DropTest2:
  material: STONE
  options:
    charge: 3

# Owner功能测试
OwnerTest:
  material: STONE
  name: 你捡我啊
  options:
    # 通过/ni drop或击杀MM怪物掉落该物品, 该物品首次拾取只能由Neige完成
    # 你可以在此处填写"%player_name%", 这样就是谁击杀就属于谁了
    # 首次拾取后将不再有掉落物归属效果
    # 服务器重启后效果重置(掉了, 关服了, 再次开服, 谁都能捡)
    owner: Neige

# 自定义动作测试
CustomAction:
  material: STONE

# 物品时限测试
ItemTimeTest:
  material: STONE
  name: 限时物品-到期时间-<js::ItemTime.js::main_<itemtime>>
  options:
    itemtime: <itemtime>
  sections:
    itemtime: 60

# join节点测试
JoinTest1:
  material: STONE
  lore:
    # 结果: 1, 2, 3, 4, 5
    - 'join节点: <test>'
  sections:
    test:
      type: join
      # 待操作的列表
      list:
        - 1
        - 2
        - 3
        - 4
        - 5
JoinTest2:
  material: STONE
  lore:
    # 结果: 1-2-3-4-5
    - 'join节点: <test>'
  sections:
    test:
      type: join
      list:
        - 1
        - 2
        - 3
        - 4
        - 5
      # 分隔符(默认为", )
      separator: "-"
JoinTest3:
  material: STONE
  lore:
    # 结果: <1, 2, 3, 4, 5>
    - 'join节点: <test>'
  sections:
    test:
      type: join
      list:
        - 1
        - 2
        - 3
        - 4
        - 5
      # 前缀
      prefix: "<"
      # 后缀
      postfix: ">"
JoinTest4:
  material: STONE
  lore:
    # 结果: 1, 2, 3
    - 'join节点: <test>'
  sections:
    test:
      type: join
      list:
        - 1
        - 2
        - 3
        - 4
        - 5
      # 限制长度
      limit: 3
JoinTest5:
  material: STONE
  lore:
    # 结果: 1, 2, 3, ...
    - 'join节点: <test>'
  sections:
    test:
      type: join
      list:
        - 1
        - 2
        - 3
        - 4
        - 5
      limit: 3
      # 超过长度的部分用该符号代替
      truncated: "..."
JoinTest6:
  material: STONE
  lore:
    # 结果: 2, 3, 4, 5, 6
    - 'join节点: <test>'
  sections:
    test:
      type: join
      list:
        - 1
        - 2
        - 3
        - 4
        - 5
      # 对列表中的每个元素进行一定操作
      # this.it代表当前元素
      # this.index代表当前序号(0代表第一个, 1代表第二个, 以此类推)
      # this.player代表玩家
      # this.vars(String string)用于解析节点
      # List<String> this.list代表节点中的list
      transform: |-
        // 尝试将当前元素转换为整数, 并加一, 然后保留整数
        return (parseInt(this.it) + 1).toFixed(0)
JoinTest7:
  material: STONE
  lore:
    # 等同于:
    # - 第一行
    # - 第二行
    # - 第三行
    #
    # 这个节点应该单独占据一行
    # 不要在这行写其他文本(比如'join节点: <test>')
    # 具体请自行测试
    - '<test>'
  sections:
    test:
      type: join
      list:
        - 第一行
        - 第二行
        - 第三行
      # 像下面这样写分隔符、前缀和后缀
      # 即可达到调用多行lore的效果
      separator: "\\n"
      prefix: '"'
      postfix: '"'
GaussianTest:
  material: STONE
  lore:
    - '随机数: <test>'
    # <gaussian::基础数值_浮动单位_浮动范围上限_取整位数(默认为1, 可省略)_数值下限(可省略)_数值上限(可省略)>
    - '随机数: <gaussian::100_0.1_0.5_1>'
  sections:
    test:
      type: gaussian
      # 基础数值
      base: 100
      # 浮动单位
      spread: 0.1
      # 浮动范围上限
      maxSpread: 0.5
      # 取整位数(默认为1)
      fixed: 1
      # 数值下限
      min: 0
      # 数值上限
      max: 10000
# 不使用js的操作形式
RepeatTest1:
  material: STONE
  lore:
    # 结果: 形似&4||||||||||||||&f||||||, &f出现的位置随机
    - 'repeat节点: &4<repeat1>&f<repeat2>'
  sections:
    repeat1:
      type: repeat
      content: "|"
      repeat: <number>
    repeat2:
      type: repeat
      content: "|"
      repeat: <calculation::20-<number>>
    number:
      type: number
      min: 0
      max: 20
      fixed: 0
# 使用js的操作形式
RepeatTest2:
  material: STONE
  lore:
    # 结果: 形似&4||||||||||||||&f||||||, &f出现的位置随机
    - 'repeat节点: <repeat>'
  sections:
    repeat:
      type: repeat
      content: "|"
      repeat: 20
      prefix: "§4"
      # 对列表中的每个元素进行一定操作
      # this.it代表content
      # this.index代表当前序号(0代表第一个, 1代表第二个, 以此类推)
      # this.player代表玩家
      # this.vars(String string)用于解析节点
      transform: |-
        if (this.index == this.vars("<number>")) {
            return "§f" + this.it
        } else {
            return this.it
        }
    number:
      type: number
      min: 0
      max: 20
      fixed: 0
RepeatTest3:
  material: STONE
  lore:
    # 随机1-4行"&4&l<红宝石槽>"
    - '<repeat>'
  sections:
    repeat:
      type: repeat
      content: '&4&l<红宝石槽>'
      repeat: <number::1_4_0>
      # 像下面这样写分隔符、前缀和后缀
      # 即可达到调用多行lore的效果
      separator: "\\n"
      prefix: '"'
      postfix: '"'
RepeatTest4:
  material: STONE
  lore:
    # 形似"§4§l<★>-§4§l<★>-§4§l<★>", 随机1-4个
    - '<repeat>'
  sections:
    repeat:
      type: repeat
      content: '§4§l<★>'
      repeat: <number::1_4_0>
      separator: "-"
